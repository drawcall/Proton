<!DOCTYPE html>
<html>
<head>
    <title>Proton with Pixi.js v8 Example</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            width: 100%;
            height: 100%;
        }
        #canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <!-- Import Pixi.js v8 -->
    <script src="https://pixijs.download/v8.8.1/pixi.min.js"></script>
    <!-- Import Proton - Use proton.web.js instead of proton.js -->
    <script src="../build/proton.web.js"></script>
</head>
<body>
    <div id="canvas"></div>

    <script>
        // Initialize Pixi.js v8 application (async)
        (async function() {
            // Create Pixi Application with v8
            const app = new PIXI.Application();
            
            // Initialize the application
            await app.init({
                resizeTo: window,
                background: '#000',
                antialias: true,
            });
            
            // Add the view to the DOM
            document.getElementById('canvas').appendChild(app.canvas);
            
            // Create a Proton instance - use Proton directly without window.
            const proton = new Proton();
            
            // Create left emitter with warm colors
            const leftEmitter = new Proton.Emitter();
            leftEmitter.rate = new Proton.Rate(new Proton.Span(50, 80), new Proton.Span(0.01, 0.05));
            
            // Set left emitter position to left side of screen
            leftEmitter.p.x = app.screen.width * 0.25;
            leftEmitter.p.y = app.screen.height / 2;
            
            // Configure the left emitter particles
            leftEmitter.addInitialize(new Proton.Mass(1));
            leftEmitter.addInitialize(new Proton.Radius(new Proton.Span(10, 30)));
            leftEmitter.addInitialize(new Proton.Life(1, 3));
            leftEmitter.addInitialize(new Proton.Velocity(new Proton.Span(2, 4), new Proton.Span(0, 360), 'polar'));
            
            // Add behaviors with warm colors
            leftEmitter.addBehaviour(new Proton.Color(['#FF0026', '#FF5500', '#FFAA00', '#FFFF00']));
            leftEmitter.addBehaviour(new Proton.Alpha(1, 0));
            leftEmitter.addBehaviour(new Proton.Scale(1, 0.5));
            
            // Create right emitter with cold colors
            const rightEmitter = new Proton.Emitter();
            rightEmitter.rate = new Proton.Rate(new Proton.Span(50, 80), new Proton.Span(0.01, 0.05));
            
            // Set right emitter position to right side of screen
            rightEmitter.p.x = app.screen.width * 0.75;
            rightEmitter.p.y = app.screen.height / 2;
            
            // Configure the right emitter particles
            rightEmitter.addInitialize(new Proton.Mass(1));
            rightEmitter.addInitialize(new Proton.Radius(new Proton.Span(10, 30)));
            rightEmitter.addInitialize(new Proton.Life(1, 3));
            rightEmitter.addInitialize(new Proton.Velocity(new Proton.Span(2, 4), new Proton.Span(0, 360), 'polar'));
            
            // Add behaviors with cold colors
            rightEmitter.addBehaviour(new Proton.Color(['#00FFFF', '#0000FF', '#0055FF', '#00FF35']));
            rightEmitter.addBehaviour(new Proton.Alpha(1, 0));
            rightEmitter.addBehaviour(new Proton.Scale(1, 0.5));
            
            // Add the Pixi renderer to Proton
            const renderer = new Proton.PixiRenderer(app.stage);
            proton.addRenderer(renderer);
            
            // Start both emitters
            leftEmitter.emit();
            rightEmitter.emit();
            proton.addEmitter(leftEmitter);
            proton.addEmitter(rightEmitter);
            
            // Create text to display particle count and renderer info
            const countText = new PIXI.Text({
                text: 'Particles: 0\nRenderer: ' + app.renderer.type,
                style: {
                    fontFamily: 'Arial',
                    fontSize: 16,
                    fill: 0xffffff,
                    align: 'left'
                }
            });
            countText.position.set(10, 10);
            app.stage.addChild(countText);
            
            // Update Proton in animation loop
            app.ticker.add(() => {
                proton.update();
                
                // Update particle count display and show detailed renderer info
                const particleCount = proton.getCount();
                
                // Map renderer type numbers to names
                const rendererTypes = {
                    0: 'Unknown',
                    1: 'WebGL',
                    2: 'WebGPU',
                    3: 'Canvas2D'
                };
                
                // Get detailed renderer information
                let rendererType = app.renderer.type;
                let detailedType = rendererTypes[rendererType] || "Unknown";
                
                // Add more specific information for WebGL
                if (rendererType === 1 && app.renderer.gl) {
                    try {
                        const version = app.renderer.gl.getParameter(app.renderer.gl.VERSION);
                        const vendor = app.renderer.gl.getParameter(app.renderer.gl.VENDOR);
                        detailedType += ` (${version} - ${vendor})`;
                    } catch (e) {
                        // Fallback if parameter retrieval fails
                        if (app.renderer.gl.webGLVersion) {
                            detailedType += ` ${app.renderer.gl.webGLVersion}.0`;
                        }
                    }
                }
                
                // Print additional GPU info for WebGPU if available
                if (rendererType === 2 && app.renderer.gpu) {
                    try {
                        const adapter = app.renderer.gpu.adapter;
                        if (adapter && adapter.name) {
                            detailedType += ` (${adapter.name})`;
                        }
                    } catch (e) {
                        // Ignore errors when trying to get adapter info
                    }
                }
                
                countText.text = `Particles: ${particleCount}\nRenderer: ${rendererTypes[rendererType]} (${rendererType})`;
                
                // Add GPU info if we have it
                if (detailedType !== rendererTypes[rendererType]) {
                    countText.text += `\nGPU: ${detailedType}`;
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                leftEmitter.p.x = app.screen.width * 0.25;
                leftEmitter.p.y = app.screen.height / 2;
                rightEmitter.p.x = app.screen.width * 0.75;
                rightEmitter.p.y = app.screen.height / 2;
            });
        })();
    </script>
</body>
</html> 